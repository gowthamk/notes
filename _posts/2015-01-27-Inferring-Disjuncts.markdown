---
layout: post
title:  "Inferring Disjuncts"
--- 

We have [previously][tireview] remarked that naive enumeration of set
of all possible hypotheses allowed by the grammar is not going to
scale as the grammar becomes bigger. As a solution, we proposed to
keep the grammar small by choosing not to add additional relational
operators like minus, intersection, and operators like IF-THEN-ELSE.
We demonstrated that the loss in expressivity can be recuperated with
help of rich primitive relations. To avoid blowing up candidate state
space, we propose to keep the set of primitive relations small by
including only a small number of pre-defined primitive relations,
while inferring the rest on case-by-case basis.

Although the approach of inferring appropriate primitive relations to
construct relational types keeps candidate state space in check, the
state space is still expected to contain a large number of candidate
invariants, and a large number of candidate disjuncts for each
invariant. Most of these candidate invariants and candidate disjuncts
are spurious. For example, consider the `filter_neq_concat` function,
which concats elements of `l1` that are not equal to `id` to `l2`.
Its relational type makes use of the primitive relation `RNeq` defined
as `RNeq = \y.\x.{x} - {y}`. Observe that `RNeq y x = {x}` if `xâ‰ y`,
and `RNeq y x = {}` otherwise. The type is shown below:

    filter_neq_concat : (l1,id) -> l2 
          -> { l | Rmem[RId](l) = Rmem[RNeq id](l1) U Rmem[RId](l2)}

Assume that we somehow know that the relation `RNeq id` is going to be
useful to construct the type of `filter_neq`, letting us include `RNeq
id` in the syntactic class of primitive relations. Now, hypothesis
generator would also generate a candidate invariant for `Rmem[RNeq
id]` abstraction of the result list (`l`), which is useless as there
does not exist any invariant on `Rmem[RNeq](l)`.

Likewise, for the `subst` function, assume that we know that the
following primitive relation is going to be useful:

    Rsubst = \id.\e.\x. IF x=id THEN Rfv(e) ELSE {}

We, therefore include it in the syntactic class of primitive
relations. The actual type of `subst` function that makes use of the
`Rsubst` relation is shown below:

    subst : e1 -> id -> e2 -> {e | Rfv[RId](e) = Rfv[Rsubst id e1](e2)}

However, there is no reason why a naive hypothesis generator shouldn't
consider `Rfv[Rsubst id e2](e1)` or `Rfv[Rsubst id e1](e)` or
`Rfv[Rsubst id e2]e`. The hypothesis generator therefore includes
these in the set of candidate disjuncts of all invariants, besides
generating candidate invariants for `Rfv[Rsubst id e1](e)` and
`Rfv[Rsubst id e1](e)`. This is futile as the invariants are doomed to
be invalid, and the valid invariant for `Rfv[RId](e)` does not contain
the disjunct `Rfv[Rsubst id e2](e1)`.

Generating candidate invariants for inappropriate relational
abstractions of the result data structure, and including irrelevant
atoms as candidate disjuncts of an invariant happens even in the
absence of parametric relations. For `concat` function, the hypothesis
generator generates candidate invariants for `Rhd` abstraction of the
result list, when clearly none are valid. Likewise, for `Robs`
abstraction, the generator generates 20 atomic disjuncts when the
final invariant only contains 3. In the context, the following
question assumes significance:

    What relational abstractions of the result are likely to satisfy
    some non-trivial invariants? For each invariant, what are the
    disjuncts that are likely to be in the final solution?

This wiki documents an attempt to solve this problem. Specifically, I
describe an algorithm that, given a VC with a hole denoting unknown
type refinement, generates a set of candidate invariants that are
likely to be part of the type refinement. Theoretical properties of
the algorithm are not yet clear, but the aim is to achieve
completeness at the expense of soundness.

Insights
------------

I will first present some insights that are key to the working of the
algorithm. For a moment, forget about type inference and assume that
we are trying to check the concat function against the following
type (Lets assume we only have `Rmem` and `Rhd` relations):

    concat : x_0 -> x_1 -> { v_11 | Rmem(v_11) = Rmem(x_0) U Rmem(x_1)};

Here is the definition of concat:

    fun concat x_0 x_1 = case x_0 of
        [] => x_1
      | x::xs => x::(concat xs x_1)

And here is a VC generated by catalyst along `x_0=x::xs` branch of
concat:

    bindings(
       v_11 :  'a_4258 list,
       x_1 :  'a_4258 list,
       x_0 :  'a_4258 list,
       anc_18 :  'a_4258 list,
       anc_19 :  'a_4258 list,
       l1 :  'a_4258 list,
       l2 :  'a_4258 list,
       x : 'a_4258,
       xs :  'a_4258 list,
       anc_21 : 'a_4258,
       anc_24 :  'a_4258 list)
    in
          anc_19 = x_1
          anc_18 = x_0
          l2 = x_1
          l2 = anc_19
          l1 = x_0
          l1 = anc_18
          Rmem(l1) = ({(x)} U Rmem(xs))
          Rhd(l1) = {(x)}
          Rmem(anc_24) = Rmem(xs) U Rmem(l2)
          anc_21 = x
          Rmem(v_11) = ({(anc_21)} U Rmem(anc_24))
          Rhd(v_11) = {(anc_21)}
       =>
          Rmem(v_11) = Rmem(x_0) U Rmem(x_1)
    end

Notice that VC contains several variables (e.g: `anc_18`, `anc_19`)
that are not present in the original definition concat, along with
their relational abstractions (`Rmem(anc_24)`). The variables resulted
from a-normalization of the original program, and their relational
abstractions from invariants of various function calls (in this case a
recursive call). Observe that for each newly introduced variable, VC
contains an equation that either defines (1). the variable as being
equal to an existing variable, or (2). its relational abstraction in
terms of relational abstractions of existing variables. Let us use
these equations to eliminate as many variables as possible. The
resulting simplified VC is shown below:

    bindings(
       v_11 :  'a_4258 list,
       x_1 :  'a_4258 list,
       x_0 :  'a_4258 list,
       x : 'a_4258,
       xs :  'a_4258 list,
    in
          Rmem(x_0) = ({(x)} U Rmem(xs))
          Rhd(x_0) = {(x)}
          Rmem(v_11) = ({(x)} U (Rmem(xs) U Rmem(x_1)))
          Rhd(v_11) = {(x)}
       =>
          Rmem(v_11) = Rmem(x_0) U Rmem(x_1)
    end

We make the following observations about the simplified VC:

1. The only variables present in the simplified VC are either inputs
   themselves (`x_0`, `x_1`), or the pattern variables (`x`, `xs`). 
2. For the invariant about `Rmem(v_11)` to be proved as the consequent
   of the VC (i.e., `Rmem(v_11) = Rmem(x_0) U Rmem(x_1)`), *there
   exists a corresponding equation* in the antecedent of the VC
   defining `Rmem(v_11)` in terms of relational abstractions of input
   and pattern variables.
3. The only difference between `Rmem(v_11)` equations in antecedent
   and consequent are *pattern variables*. If we eliminate pattern
   variables from the equation in antecedent, the resultant equation
   must be equivalent (or even syntactically equal) to the equation in
   consequent. We can use the solver to discharge this check, keeping
   the role of the solver to the bare minimum.
4. How do we eliminate pattern variables? By *unification*! We try to
   unify the RHS of `Rmem(v_11)` equation in the antecedent with
   equations of input relational abstractions. In this case, since
   would like to eliminate `{(x)}` and `Rmem(xs)` from the equation,
   we look for equations on inputs `x_0` and `x_1` that contain
   `{(x)}` or `Rmem(xs)`, or both in their RHS. We find two equations,
   one on `Rmem(x_0)` and one on `Rhd(x_0)` satisfying the criterion.
   Based on actual mechanics of unification, we may end up with one of
   the following equations in the the antecedent: 
   1. `Rmem(v_11) = Rhd(x_0) U Rmem(x_0) U Rmem(x_1)`
   2. `Rmem(v_11) = Rmem(x_0) U Rmem(x_1)`
   Solver determines that both equations are indeed equivalent to the
   equation in the consequent, thus discharging the VC.

Now, consider the type inference problem, where we don't know the
invariant satisfied by concat; our job is to infer it. The VC
generated in this case will have a hole in place of the consequent,
along with a hole in the antecedent denoting the unknown invariant
satisfied by the recursive call. Nevertheless, we can perform the same
simplification as before to eliminate intermediary variables, and
their relational abstractions. However, simplification will not be
successful in eliminating all the intermediary variables; along with
the input and pattern variables, the simplified VC also contains *one
variable* denoting the result of the recursive call. We cannot
eliminate this variable as we do not know of any equations satisfied
by this variable; they are yet to be inferred. Yet, the inferred type
refinement (which is a conjunction of invariants) should make no
reference to this variable, as it is neither input of concat, not its
output. How do we go about inferring invariants in the unknown type
refinement?

We make use of the observation number 2 listed above, and start from a
known equation on the result list (`v_11`). A relational abstraction
of the result list for which an equation is not present in the VC is
not worth considering as there clearly is no way to prove any
invariant over that abstraction. This observation is quite useful
while inferring types for functions like `rev`, which have a tail call
to some other function; if the tail call only gives us invariants on
`Rmem` and `Robs` (like tail call to concat does in case of rev),
there is no point trying to prove invariants on `Rhd` and `Roas` for
there is no way to prove them. This lets us ignore `Rhd` and `Roas`
invariants in the type refinement -  a clear advantage over _naive
enumeration + CEGIS_ method which spends considerable time before
figuring out this fact.

Starting from a known equation of the result list (`v_11`), we proceed
in the same way as before and try to eliminate pattern variables by
unifying RHS with equations on the input lists. This unification
is not straightforward as the equation on result list most often
refers to the result of the recursive call, which cannot be unified.
Instead, unification has to rely on inductive hypothesis.  For
example, consider the following known equation on the result list of
concat, referring to the pattern variable `x` and the result of the
recursive call `anc_24`:

    Rmem(v_11) = {(x)} U Rmem(anc_24)

`x` is a pattern variable, which we would like eliminate. Scanning the
VC, we find the following equation on the the input `x_0`, which
refers to `{(x)}` on is RHS:

    Rmem(x_0) = {(x)} U Rmem(xs)

Let us say we want to eliminate `{(x)}` making use of this equation
(i.e., by unifying RHS of this equation to the RHS of the equation on
`Rmem(v_11)`). This decision has two consequences:

1. Assume: If the unification is succesful, it means that `Rmem(x_0)`,
   which we know to be equal to `{(x)} U Rmem(xs)` is infact equal to
   `Rmem(x_0) U S0`, for some unknown relational expression `S0`. In
   other words, the type of concat is: `concat: x_0 -> x_1 -> {v_11 |
   Rmem(v_11) = Rmem(x_0) U S0}`. Let us *assume* that unification is
   successful and take the type for granted. Since `anc_24` is the
   result of the recursive call (`concat xs l2`), we now have the
   following invariant from its type: `Rmem(anc_24) = Rmem(xs) U S1`,
   where `S1` is some unknown relational expression. Let us add this
   equation to the VC. It remains to prove that unification will
   indeed be successful.
2. Guarantee: Since there is now a new equation (on `Rmem(anc_24)`) in
   the VC, we redo the VC simplification. This results in the equation
   on `Rmem(v_11)` changing to the following: `Rmem(v_11) = {(x)} U
   Rmem(xs) U S1`. Observe that this is easily unifiable with the
   equation on `Rmem(x_0)`, this vindicating our assumption that
   unification will be successful. 

As a result of the _assume-guarantee_ style reasoning described above,
we now know that an invariant on `Rmem(v_11)` can contain the disjunct
`Rmem(x_0)` along the branch that generated this VC. If `Rmem(x_0) âŠ†
Rmem(v_11)` is also valid along other branches, then we are sure that
`Rmem(x_0)` is one of the disjuncts of the invariant on `Rmem(v_11)`
in the type refinement of concat. 

I have manually applied the method described above to `concat` and
`rev` examples trying to discover disjuncts. In the both the examples,
the method generated all disjuncts (completeness) and only those
disjuncts (soundness) that are part of the final solution . However,
its theoretical properties, in general, are not clear. Moreover, as we
develop the method to work for more complex examples, we might have to
expend soundness to retain completeness.

The rest of this wiki describes the unification process in greater
detail, by demonstrating over concat and rev examples.

Concat Example
--------------

As usual, we start with the `concat` example. Since our type inference
operates on a-normal representation of SML, we consider an elaborated
a-normal form of `concat`:

    val rec concat = (fn x_0 => (fn x_1 =>
      let val anc_27 = x_0
          val anc_28 = x_1
      in
         case (anc_27, anc_28) of
           (l1, l2) =>
           case l1 of
             [] => l2
           | ::(x, xs) =>
             let val anc_29 = :: 
                 val anc_30 = x
                 val anc_31 = concat
                 val anc_32 = (anc_31 xs)
                 val anc_33 = (anc_32 l2)
                 val v_11 = (anc_29 (anc_30, anc_33))
             in
                v_11
             end
      end))

In accordance with the structure of the program, the template
relational type of `concat` is:

    concat : x_0 -> x_1 -> {l | ??}

To focus on relevant issues, let us only consider non-parametric
relational abstractions of list type, i.e., `Rhd`, `Rmem`, `Robs`, and
`Roas`, in the same order. We initially generate verfication
conditions (VCs) for both branches of concat. Since we do not yet know
the invariant satisfied by concat, it is represented as a hole (e.g:
`??0`) in the VC. Assume that we draw invariants from the simple
grammar shown below:

$$
\begin{array}{lcl}
R & \in & Structural\; Relations\\
v & \in & Variables\; in\; scope\\
Ratom & ::= & R(v) \;|\; R(v) \times Ratom\\
Rexpr & ::= & Ratom \;|\; Ratom \cup Rexpr \\
\phi & ::= & Rapp = Rexpr \;|\; \phi \wedge \phi\\
\end{array}
$$

First, let us consider the `l1=[]` branch of `concat`. The
corresponding VC is here:

    bindings(
      v_11 :  'a_4258 list,
       x_1 :  'a_4258 list,
       x_0 :  'a_4258 list,
       anc_18 :  'a_4258 list,
       anc_19 :  'a_4258 list,
       l1 :  'a_4258 list,
       l2 :  'a_4258 list)
    in
          anc_19 = x_1
          anc_18 = x_0
          l2 = x_1
          l2 = anc_19
          l1 = x_0
          l1 = anc_18
          Roas(l1) = {()}
          Roa(l1) = {()}
          Robs(l1) = {()}
          Rob(l1) = {()}
          Rmem(l1) = {()}
          Rhd(l1) = {()}
          v_11 = x_1
          v_11 = anc_19
          v_11 = l2
       =>
          ??0
    end

One way to look at the above VC to view it as a set of equational
constraints. The solution to constraints should express the result
variable `v_11`, or its relational abstractions in terms of input
variables `{x_0,x_1}`, or their relational abstractions. Solving the
constraints, we obtain the solution `v_11 = l2`, which means that for
any relational abstraction (`R`) of the list type, `R(v_11) = R(l2)`. 

Given that we have performed the above analysis, what did we learn
about the structure of unknown invariant `??0`? We now know that for
any relational abstraction `R` of the list type, if `0??` contains an
invariant on `R(v_11)`, it will be of form `R(v_11) = R(x_1) U S0`
(recall that there is no minus or primitive relations in our grammar),
where `S0` is a relational expression such that `S0 = {}` is valid
under the conditions captured by the current VC. We record this
observation as a constraint on `??0` (lets call it _C-1_):

$$R\in\{R_{hd},R_{mem},R_{obs},R_{oas}\},\; S0={} \vdash R(v_{11}) = R(x_1)
\cup S0$$

In the absence of any other constraints, we accept the trivial
solution of `S0={}`, leading to the following solution for the hole
`??0`:

    Rhd(v_11) = Rhd(x_1) /\ 
    Rmem(v_11) = Rmem(x_1) /\ 
    Robs(v_11) = Robs(x_1) /\ 
    Roas(v_11) = Roas(x_1)

Observe that this is more or less similar to how Catalyst currently
operates on non-recursive functions, for which no type annotations are
needed.

Now, lets move on to the `l1=x::xs` branch. The VC is shown below:

    bindings(
       v_11 :  'a_4258 list,
       x_1 :  'a_4258 list,
       x_0 :  'a_4258 list,
       anc_18 :  'a_4258 list,
       anc_19 :  'a_4258 list,
       l1 :  'a_4258 list,
       l2 :  'a_4258 list,
       x : 'a_4258,
       xs :  'a_4258 list,
       anc_21 : 'a_4258,
       anc_24 :  'a_4258 list)
    in
          anc_19 = x_1
          anc_18 = x_0
          l2 = x_1
          l2 = anc_19
          l1 = x_0
          l1 = anc_18
          Roas(l1) = ((Rmem(xs) X {(x)}) U Roas(xs))
          Roa(l1) = (Rmem(xs) X {(x)})
          Robs(l1) = (({(x)} X Rmem(xs)) U Robs(xs))
          Rob(l1) = ({(x)} X Rmem(xs))
          Rmem(l1) = ({(x)} U Rmem(xs))
          Rhd(l1) = {(x)}
          [[anc_24/v_11], [l2/x_1], [xs/x_0]] ??0
          anc_21 = x
          Roas(v_11) = ((Rmem(anc_24) X {(anc_21)}) U Roas(anc_24))
          Roa(v_11) = (Rmem(anc_24) X {(anc_21)})
          Robs(v_11) = (({(anc_21)} X Rmem(anc_24)) U Robs(anc_24))
          Rob(v_11) = ({(anc_21)} X Rmem(anc_24))
          Rmem(v_11) = ({(anc_21)} U Rmem(anc_24))
          Rhd(v_11) = {(anc_21)}
       =>
          ??0
    end

After simplification, we are left with following residual constraints,
which cannot be solved any further by mere equational reasoning 

    Roas(x_0) = ((Rmem(xs) X {(x)}) U Roas(xs))
    Roa(x_0) = (Rmem(xs) X {(x)})
    Robs(x_0) = (({(x)} X Rmem(xs)) U Robs(xs))
    Rob(x_0) = ({(x)} X Rmem(xs))
    Rmem(x_0) = ({(x)} U Rmem(xs))
    Rhd(x_0) = {(x)}
    [[anc_24/v_11], [x_1/x_1], [xs/x_0]] ??0
    Roas(v_11) = ((Rmem(anc_24) X {(x)}) U Roas(anc_24))
    Roa(v_11) = (Rmem(anc_24) X {(x)})
    Robs(v_11) = (({(x)} X Rmem(anc_24)) U Robs(anc_24))
    Rob(v_11) = ({(x)} X Rmem(anc_24))
    Rmem(v_11) = ({(x)} U Rmem(anc_24))
    Rhd(v_11) = {(x)}

<!-- After simplification, there won't be any transitive dependencies.
-->

Let us now consider relational abstractions of the result list
(`v_11`), one-by-one. Consider `Rhd(v_11)`. We know that `Rhd(v_11) =
{(x)}`, but the freevars of RHS of this equation are not subset of
`{x_0,x_1}`, hence the equation cannot serve as an invariant. However,
the equation should guide us towards the relevant invariant. The
process is described below:

First, we start with a simple conjecture that the final invariant on
`Rhd(v_11)` contains only one disjunct, which is a relational
abstraction of either `x_0` or `x_1`. This means that `Rhd(v_11)`,
which is equal to `{(x)}`, needs to be _unified_ with any of the
relational abstractions of `x_0` or `x_1`. This unification is more
than a mere syntactic unification. Let `A` be unification algorithm,
which achieves this. `A` poses questions of the following form to
solver under the context of above equations:

    {(x)} = R(z)?

Where `R âˆˆ {Rhd,Rmem}` and `z âˆˆ {x_0,x_1}`. Solver answers that `{(x)}
= Rhd(x_0)` is indeed valid, letting `A` to unify `{(x)}` and
`Rhd(x_0)`. Hence `Rhd(v_11)=Rhd(x_0)` is a potential invariant.
However, the solution does not satisfy the constraint _c-1_ recorded
in the `l1=[]` branch, leading to its disqualification. There are no
more potential invariants with RHS containing only one disjunct. 

We now refine our conjecture and consider invariants on `Rhd(v_11)`,
whose RHS is a union at the top-level. Since we consider
left-associative grammar, We have `Rhd(v_11) = S0 U S1`, where `S0` is
a relational atom (a disjunct), and `S1` is a relational expression.
Since `Rhd(v_11) = {(x)}` has only one disjunct (`{(x)}`), `S0={(x)}`
and `S1={}`, which is also an atom. We now invoke `A({(x)} U {})`.
`A(atom1 U atom2)` is defined as following:

    A(atom1 U atom2) = A(atom1) U A(atom2)

`A(atom2)` cannot be solved as there does not exist a relational
abstraction of either `x_0` or `x_1` that is an empty set.  Now, since
`S1` is already an empty set, it cannot be split further as `S2 U S3`
such that alteast one of `S2` or `S3` are not equal to `S1`. In other
words, fixpoint is reached and there is no use of considering
conjectures involving three or more disjuncts. To conclude, the
inference process has correctly failed to infer an invariant for
`Rhd(v_11)`, as there exists none.

Now, lets consider `Rmem(v_11)`. We know that `Rmem(v_11) = {(x)} U
Rmem(anc_24)`, but the freevars of RHS of this equation are not subset
of `{x_0,x_1}`, hence the equation cannot serve as an invariant. We
therefore use the equation to _unify_ `Rmem(v_11)` with relational
abstractions of `x_0` and `x_1`, in the same way as `Rhd(v_11)`.

As usual, we start with the conjecture that invariant for `Rmem(v_11)`
contains one disjunct, and rely on `A` to infer the disjunct. We call
`A(Rmem(v_11)=re)`, where `re` is a relational expression that is
equal to `{(x)} U Rmem(anc_24)` (we write it this way to emphasize the
fact that `A` is oblivious of the internal structure of `re`). This
fails, as no invariant of the following form is valid for `R âˆˆ
{Rhd,Rmem}` and `z âˆˆ {x_0,x_1}`:

    {(x)} U Rmem(anc_24) = R(z)?

We therefore refine our conjecture, and consider invariants with two
disjuncts. That is, we consider `A(Rmem(v_11) = {(x)} U re)`, where
`re = Rmem(anc_24)`. Here is how `A` works with predicates of form
`R(v) = atom U relexp`:

1. First, it tries to unify `atom` with existing relational
   abstractions of `{x_0,x_1}`. Let us say that it is successful, and
   yeilds `R'(x_0)` (alternatively, `R'(x_1)`), where `R' âˆˆ
   {Rhd,Rmem}`. Then, we conjecture that invariant is of form
   `R(v_11)= R'(x_0) U ..`. Since invariant is a type refinement, it
   needs to be instantiated for the recursive call as well. Doing so
   lets us infer that `R(anc_24) = R'(xs) U ...`, allowing us to
   deduce `R'(xs) âŠ† R(anc_24)`. Lets refer to this proposition as
   $$\phi 1$$. (In case if the unification fails, we go directly to
   step 3).
2. Assuming $$\phi 1$$, `A` now tries to unify `relexp` with existing
   relational abstractions of `{x_0,x_1}`. This is a recursive call,
   which may yeild one of the following three results:
   1. The unification may fail, which means that it is provably
      impossible to unify to `relexp` with any of the existing
      abstractions. This happens when `relexp` is a constant set (e.g:
      an empty set), and the propositions of form `R(z) = relexp` are
      not only invalid, but also unsatisfiable.
   2. The unification may succeed, in which case the recursive call
      yeilds an `re'` such that `freevars(re')âŠ†{x_0,x_1}`. In this
      case, we record the equation `R(v) = R'(x_0) U R''(x_1)`
      (alternatively, `R(v) = R'(x_1) U R''(x_0)`) yeilds `R''(x_1)`
      as a potential invariant, and move on to next step.
   3. The unification does not succeed, but does not fail either. This
      means that there may exist an `re'` such that
      `freevars(re')âŠ†{x_0,x_1}`, and `re' = re`, but with the given
      information, it is impossible to deduce what that `re'` is.  In
      this case, we record that record `R(v) = R'(x_0) U S6`
      (alternatively, `R(v) = R'(x_1) U S6`), for some unknown `S6`.
      The unknown `S6` captures our inability to finish unification of
      `atom U relexp` only using the local information.
3. Instead of trying to unify `atom` and `relexp` seperately, `A` now
   considers both of them at the same time. That is, `A` now tries to
   find `R'(x_0)` (or, `R''(x_1)`) such that `R'(x_0) = atom U re'`
   and `re' âŠ† relexp`. Here is how `A` does it:
   1. `A` tries to unify `atom U S7`, for some unknown non-empty set
      `S7`.
   2. `A` may succeed, yeilding `R'(x_0)` (or, `R''(x_1)`), along with
      a constraint on `S7` that `S7=re'`, where `re'` is a relational
      expression such that `freevars(re') âŠ† {x_0,x_1}`.  We are now
      obligated to prove that `re'âŠ† relexp`. Lets call this proof
      obligation as $$G1$$.
   3. If `A` succeeds, then we conjecture that invariant will be of
      form `R(v) = R'(x_0) U ...` (alternatively, `R(v) = R''(x_1) U
      ...`)<!-- , where `S8 U re'' = relexp` -->. By inductive
      hypothesis, we have that `R(anc_24) = R'(xs) U ...` (or,
      `R(anc_24) = R''(x_1) U ...`), which lets us deduce that `R'(xs)
      âŠ† R(anc_24)` (or, R''(x_1) âŠ† R(anc_24)). Lets call this
      proposition as $$\phi 2$$. We now add $$\phi 2$$ to the context,
      and try to discharge the pending proof obligation $$G1$$. If
      $$G1$$ is discharged, then `R(v) = R'(x_0) U S8` (alternatively,
      `R(v) = R''(x_1) U S8`) is recorded as a potential invariant
      (for some unknown `S8`), and the algorithm terminates.
    4. On the other hand, if `A` does not succeed, then it means that
       there does not exist a `R'(x_0)` or `R''(x_1)` that is equal to
       `atom U re'`, for some re'. The algorithm simpy reports the
       potential invariants found so far and terminates.

Following the algorithm described above, `A` infers that invariants
over `Rmem(v_11)` can be of form `Rmem(v_11) = Rhd(x_0) U S6`, or
`Rmem(v_11) = Rmem(x_0) U S8`. Recall that from `x_0=[]` branch, we
already have a potential invariant `Rmem(v_11) = Rmem(x_1) U S0`, where
`S0` is obligated to be equivalent to an empty set under the branch
condition. Combining them and eliminating the unification variables
`S0`, `S6`, and `S7`, we arrive at the following potential invariant
for `Rmem(v_11)`:

    Rmem(v_11) = Rhd(x_0) U Rmem(x_0) U Rmem(x_1)

Which is indeed a valid invariant of concat.
 
<!--

  The algorithm A (re) = case re of
    Atom (âˆ…) => all-combinations (find-ra-eq-to (âˆ…))
  | Atom a => 
    let
      val K1 = all-combinations (find-ra-eq-to (a))
      val K2 = A(âˆ…)
      val K3 = join (K1, K2, fn (k1,k2) => k1 `U` k2)
    in
      K1 U K3
    end
  | (Atom a) `U` (re) =>
    let
      val K1 = A (Atom a)
      val K2 = A (re)
      val K3 = find-ra-sup-set-of (Atom a)
      val 
    in
    end
-->

rev example
-----------

Now, consider the `rev` example:

    fun rev l = case l of
        [] => []
      | x::xs => concat (rev xs) [x] 

Its A-normalized Core-ML version is given below:

    val rec rev = (fn x_2 => case x_2 of
       l => case l of
         [] => l
       | ::(x, xs) =>
         let val anc_23 = concat
             val anc_24 = rev
             val anc_25 = (anc_24 xs)
             val anc_26 = (anc_23 anc_25)
             val anc_27 = ::
             val anc_28 = x
             val anc_29 = nil
             val anc_30 = (anc_27 (anc_28, anc_29))
             val l' = anc_26 anc_30
         in
            l'
         end)

Let us assume that the template type for `rev` is:

    rev : x_2 -> {l' | ??}

The VC for `l=[]` branch is below:

    bindings(l : 'a_4259 list, x_2 :  'a_4259 list, l :  'a_4259 list)
    in
          l = x_2
          Roas(l) = {()}
          Robs(l) = {()}
          Roa(l) = {()}
          Rob(l) = {()}
          Rmem(l) = {()}
          Rhd(l) = {()}
          l2 = l
       =>
          ??0
    end 

Simplifying, we get the following equations:

    Roas(x_2) = {()}
    Robs(x_2) = {()}
    Roa(x_2) = {()}
    Rob(x_2) = {()}
    Rmem(x_2) = {()}
    Rhd(x_2) = {()}
    l' = x_2

Observe that `l' = x_2`, where `x_2` is the input itself. Like in the
case of `concat`, we now know that for any relational abstraction `R`
of the list type, if `0??` contains an invariant on `R(l')`, it will
be of form `R(l') = R(x_2) U S0`, where `S0` is a relational
expression such that `S0 = {}` is valid under the conditions captured
by the current VC. We record this observation as a constraint on `??0`
(lets call it _C-2_):

$$R\in\{R_{hd},R_{mem},R_{obs},R_{oas}\},\; S0={} \vdash R(l') = R(x_2)
\cup S0$$_

Lets now consider the VC from `l=x::xs` branch:

    bindings(l :  'a_4260 list,
       x_2 :  'a_4260 list,
       l :  'a_4260 list,
       x : 'a_4260,
       xs :  'a_4260 list,
       anc_25 :  'a_4260 list,
       anc_28 : 'a_4260,
       anc_29 :  'a_4260 list,
       anc_30 :  'a_4260 list)
    in
          l = x_2
          Roas(l) = ((Rmem(xs) X {(x)}) U Roas(xs))
          Roa(l) = (Rmem(xs) X {(x)})
          Robs(l) = (({(x)} X Rmem(xs)) U Robs(xs))
          Rob(l) = ({(x)} X Rmem(xs))
          Rmem(l) = ({(x)} U Rmem(xs))
          Rhd(l) = {(x)}
          Roas(anc_30) = ((Rmem(anc_29) X {(anc_28)}) U Roas(anc_29))
          Roa(anc_30) = (Rmem(anc_29) X {(anc_28)})
          Robs(anc_30) = (({(anc_28)} X Rmem(anc_29)) U Robs(anc_29))
          Rob(anc_30) = ({(anc_28)} X Rmem(anc_29))
          Rmem(anc_30) = ({(anc_28)} U Rmem(anc_29))
          Rhd(anc_30) = {(anc_28)}
          Roas(anc_29) = {()}
          Roa(anc_29) = {()}
          Robs(anc_29) = {()}
          Rob(anc_29) = {()}
          Rmem(anc_29) = {()}
          Rhd(anc_29) = {()}
          anc_28 = x
          [[anc_25/l'], [xs/x_2]] ??0
          Rmem(l) = (Rmem(anc_25) U Rmem(anc_30))
          Robs(l) = (Robs(anc_25) U (Robs(anc_30) U (Rmem(anc_25) X Rmem(anc_30))))
       =>
          ??0
    end

After some amount of constraint simplification, the equations are as
following:

    Roas(x_2) = ((Rmem(xs) X {(x)}) U Roas(xs))
    Roa(x_2) = (Rmem(xs) X {(x)})
    Robs(x_2) = (({(x)} X Rmem(xs)) U Robs(xs))
    Rob(x_2) = ({(x)} X Rmem(xs))
    Rmem(x_2) = ({(x)} U Rmem(xs))
    Rhd(x_2) = {(x)}
    Roas(anc_30) = (({()} X {(x)}) U {()})
    Roa(anc_30) = ({()} X {(x)})
    Robs(anc_30) = (({(x)} X {()}) U {()})
    Rob(anc_30) = ({(x)} X {()})
    Rmem(anc_30) = ({(x)} U {()})
    Rhd(anc_30) = {(x)}
    Roas(anc_29) = {()}
    Roa(anc_29) = {()}
    Robs(anc_29) = {()}
    Rob(anc_29) = {()}
    Rmem(anc_29) = {()}
    Rhd(anc_29) = {()}
    [[anc_25/l'], [xs/x_2]] ??0
    Rmem(l') = (Rmem(anc_25) U Rmem(anc_30))
    Robs(l') = (Robs(anc_25) U (Robs(anc_30) U (Rmem(anc_25) X Rmem(anc_30))))

After complete simplification, the equations are:

    Roas(x_2) = ((Rmem(xs) X {(x)}) U Roas(xs))
    Roa(x_2) = (Rmem(xs) X {(x)})
    Robs(x_2) = (({(x)} X Rmem(xs)) U Robs(xs))
    Rob(x_2) = ({(x)} X Rmem(xs))
    Rmem(x_2) = ({(x)} U Rmem(xs))
    Rhd(x_2) = {(x)}
    Roas(anc_30) = {()}
    Roa(anc_30) = {()} 
    Robs(anc_30) = {()}
    Rob(anc_30) = {()}
    Rmem(anc_30) = {(x)}
    Rhd(anc_30) = {(x)}
    Roas(anc_29) = {()}
    Roa(anc_29) = {()}
    Robs(anc_29) = {()}
    Rob(anc_29) = {()}
    Rmem(anc_29) = {()}
    Rhd(anc_29) = {()}
    [[anc_25/l'], [xs/x_2]] ??0
    Rmem(l') = Rmem(anc_25) U {(x)}
    Robs(l') = Robs(anc_25) U ((Rmem(anc_25) X {(x)}))

Now, we don't know what relational abstractions of result to consider.
We therefore start with known equations on the result `l'`. Consider
the equation:

    Rmem(l') = Rmem(anc_25) U {(x)}

It has a reference to `anc_25`, the return value of the recursive
call, and `x`, the pattern variable. Let us try to eliminate the
pattern variable by matching the RHS relational abstractions of the
input to `{(x)}`. We find that `Rhd(x_2)` unifies with `{(x)}`,
generating no proof obligations on `Rmem(anc_25)`. So, we discover
by analyzing VC for the `x::xs` branch that the invariant on
`Rmem(l')` can be of form `Rmem(l') = Rhd(x_2) U S1`, where `S1` is an
unknown relational expression. This means that we have the constraint
that `Rhd(x_2) âŠ† Rmem(l)` We now check if this form of invariant is
compatible with the constraint _c-2_ generated by `[]` branch:

$$R\in\{R_{hd},R_{mem},R_{obs},R_{oas}\},\; S0={} \vdash R(l') =
R(x_2)$$_

Unifying 

[tireview]: https://www.cs.purdue.edu/sss/projects/catalyst/2015/01/19/Type-Inference-Review.html

